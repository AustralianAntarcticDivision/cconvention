<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Parsing the CCAMLR Convention text. &bull; cconvention</title><!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous"><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet"><script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">cconvention</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav"><li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../articles/index.html">Articles</a>
</li>
      </ul><ul class="nav navbar-nav navbar-right"></ul></div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>Parsing the CCAMLR Convention text.</h1>
                        <h4 class="author">S. Wotherspoon</h4>
            
            <h4 class="date">18 September 2016</h4>
          </div>

    
    
<div class="contents">
<div id="ccamlr-convention-areas" class="section level2">
<h2 class="hasAnchor"><html><body><a href="#ccamlr-convention-areas" class="anchor"> </a></body></html>CCAMLR Convention Areas</h2>
<p>We are interested in parsing the <a href="https://www.ccamlr.org/en/organisation/convention-area-%E2%80%93-technical-description#48">technical description</a> of the CCAMLR convention areas.</p>
</div>
<div id="parsing" class="section level2">
<h2 class="hasAnchor"><html><body><a href="#parsing" class="anchor"> </a></body></html>Parsing</h2>
<p>Parsing is typically considered in two phases. The &ldquo;lexer&rdquo; translates the input text into &ldquo;tokens&rdquo; - the basic particles of the language, and then in the second phase the &ldquo;parser&rdquo; assembles the sequence of tokens into higher order structure according to a grammar. This is very efficient because the basic translation of input into tokens happens only once. Less sophisticated parsers will not have an explicit lexer, the tokenization is done as part of the grammar.</p>
<p>Tools like Lex and Yacc construct complex state machines for parsing - Lex constructs the lexer, and Yacc the parser. The state machines generated by tools like these are extremely efficient, but the generated code is almost impossible to understand, and the parsers they generate can be difficult to debug.</p>
<p>Parser combinators provide a modern, flexible alternative, but typically generate less efficient parsers. A parser combinator is higher order function that combines primitive parsers to form complex recursive descent parsers.</p>
</div>
<div id="parser-combinators" class="section level2">
<h2 class="hasAnchor"><html><body><a href="#parser-combinators" class="anchor"> </a></body></html>Parser Combinators</h2>
<p>There are numerous combinator libraries available, and for sophisticated parsers it would be best to use one of these. But to illustrate the basics it is simple enough to write our own combinators.</p>
<div id="no-explicit-lexer" class="section level3">
<h3 class="hasAnchor"><html><body><a href="#no-explicit-lexer" class="anchor"> </a></body></html>No Explicit Lexer</h3>
<p>Consider first the case where there is no explicit lexer.</p>
<div id="primitive-parsers" class="section level4">
<h4 class="hasAnchor"><html><body><a href="#primitive-parsers" class="anchor"> </a></body></html>Primitive Parsers</h4>
<p>We define a <code>parser</code> for a grammar to be a function accepts an input and if</p>
<ul><li><p>the input does not satisfies the grammar it returns <code>failure</code> (in our case <code>NULL</code>),</p></li>
<li>otherwise it returns a list with elements
<ul><li><code>input</code> any unconsumed input, and</li>
<li><code>result</code> the object constructed by the parse.</li>
</ul></li>
</ul><p>This function generates parsers that satisfy grammars defined by a regular expression. All the hard work is done by the regular expression matching. The value is returned as an S3 class to make it easier to write functions to format and evaluate the result.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(stringi)
<span class="kw">library</span>(Combin8R)</code></pre></div>
<p>We can use this to define a parser for an degree, minute, second specification of a coordinate</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## using this strange name for now because sp::as.character.DMS clashes otherwise
parserDMS1 &lt;-
<span class="st">  </span>Combin8R:::<span class="kw">pRegex</span>(<span class="st">"DMS1"</span>,
              <span class="st">"^</span><span class="ch">\\</span><span class="st">s*(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?</span><span class="ch">\\</span><span class="st">d?)&Atilde;&sbquo;&Acirc;&deg;(?:(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)'(?:(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)</span><span class="ch">\"</span><span class="st">)?)?(E|W|N|S)"</span>)</code></pre></div>
<p>These inputs parse</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parserDMS1</span>(<span class="st">"57&Atilde;&sbquo;&Acirc;&deg;S"</span>)</code></pre></div>
<pre><code>## $input
## [1] ""
## 
## $result
## [DMS1; 57&Atilde;&lt;U+0082&gt;&Acirc;&deg;S,57,NA,NA,S]</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parserDMS1</span>(<span class="st">"157&Atilde;&sbquo;&Acirc;&deg;20'E"</span>)</code></pre></div>
<pre><code>## $input
## [1] ""
## 
## $result
## [DMS1; 157&Atilde;&lt;U+0082&gt;&Acirc;&deg;20'E,157,20,NA,E]</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parserDMS1</span>(<span class="st">"57&Atilde;&sbquo;&Acirc;&deg;2'14</span><span class="ch">\"</span><span class="st">N"</span>)</code></pre></div>
<pre><code>## $input
## [1] ""
## 
## $result
## [DMS1; 57&Atilde;&lt;U+0082&gt;&Acirc;&deg;2'14"N,57,2,14,N]</code></pre>
<p>These fail</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parserDMS1</span>(<span class="st">"some text"</span>)
<span class="kw">parserDMS1</span>(<span class="st">"57.33S"</span>)</code></pre></div>
<p>Because the result is an S3 class, we can write a function to represent the parse results as a string</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## all in Combin8R
<span class="co"># formatAST &lt;- function(x,indent=0) {</span>
<span class="co">#   UseMethod("formatAST")</span>
<span class="co"># }</span>
<span class="co"># formatAST.default &lt;- function(x,indent=0) {</span>
<span class="co">#   pad &lt;- paste(rep(" ",indent),collapse="")</span>
<span class="co">#   paste(pad,deparse(x),sep="")</span>
<span class="co"># }</span>
<span class="co"># formatAST.pRegex &lt;- function(x,indent=0) {</span>
<span class="co">#   pad &lt;- paste(rep(" ",indent),collapse="")</span>
<span class="co">#   paste(pad,"[",class(x)[1],"; ",paste(x$value,collapse=" "),"]\n",sep="")</span>
<span class="co"># }</span></code></pre></div>
<p>So that</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">p &lt;-<span class="st"> </span><span class="kw">parserDMS1</span>(<span class="st">"57&Atilde;&sbquo;&Acirc;&deg;20'14</span><span class="ch">\"</span><span class="st">N"</span>)
<span class="kw">cat</span>(<span class="kw">formatAST</span>(p$result))</code></pre></div>
<pre><code>## [DMS1; 57&Atilde;&lt;U+0082&gt;&Acirc;&deg;20'14"N,57,20,14,N]</code></pre>
<p>Or we can write translators specific to the class</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">formatAST.DMS1 &lt;-<span class="st"> </span>function(x,<span class="dt">indent=</span><span class="dv">0</span>) {
  pad &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="kw">rep</span>(<span class="st">" "</span>,indent),<span class="dt">collapse=</span><span class="st">""</span>)
  <span class="kw">paste0</span>(pad,
         x$value[<span class="dv">1</span>],<span class="st">"&Atilde;&sbquo;&Acirc;&deg;"</span>,
         if(!<span class="kw">is.na</span>(x$value[<span class="dv">2</span>])) 
           <span class="kw">paste0</span>(x$value[<span class="dv">2</span>],<span class="st">"'"</span>,
                  if(!<span class="kw">is.na</span>(x$value[<span class="dv">3</span>])) 
                    <span class="kw">paste0</span>(x$value[<span class="dv">3</span>],<span class="st">"</span><span class="ch">\"</span><span class="st">"</span>)),
         x$value[<span class="dv">4</span>])
}</code></pre></div>
<p>So now</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="kw">formatAST</span>(p$result))</code></pre></div>
<pre><code>## 57&Atilde;&lt;U+0082&gt;&Acirc;&deg;20'14"N&Atilde;&lt;U+0082&gt;&Acirc;&deg;57'20"14</code></pre>
<p>We would also wish to write functions</p>
<ul><li><p><code>checkAST</code> - a function for sanity checking the parse. For example our DMS1 parser accepts a value of 80 for the minute field. We could refine our regular expressions to detect this an an error, but it is often easier to let the parser to focus on syntax and perform more semantic checks in a second pass.</p></li>
<li><p><code>evalAST</code> - the parser will represent the parse as a tree, this function would translate the tree to a more useful representation in terms of R objects. The alternative is to have each parser generator function accept an additional argument that is a function that is used to transform the parsed values into a more useful R representation.</p></li>
</ul></div>
<div id="combinators" class="section level4">
<h4 class="hasAnchor"><html><body><a href="#combinators" class="anchor"> </a></body></html>Combinators</h4>
<p>The parser <code>combinators</code> combine simple parsers to form more complex parsers. The combinators produce recursive descent parsers - the parser recognizes language constructs by repeated trying to find specific sequences of simpler constructs. A parser may be defined in terms of itself, provided we avoid &ldquo;left recursion&rdquo; where a construct is recognized by first recognizing a simper form of itself.</p>
<p>The alternation combinator creates a parser that succeeds on input that is accepted by any one of a number of simpler parsers. Order is important here, as this version always returns the first match. This means the grammar cannot be ambiguous in such a way that accepting the first matching pass at this stage might cause the parse to subsequently fail at a higher level, bu accepting a later match might succeed.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Combin8R:::pAlt
<span class="co"># parserAlt &lt;- function(tag,...) {</span>
<span class="co">#   ps &lt;- list(...)</span>
<span class="co">#   function(input) {</span>
<span class="co">#     ## Try each parser in turn</span>
<span class="co">#     for(p in ps) {</span>
<span class="co">#       ## Return first successful parse</span>
<span class="co">#       if(!is.null(parse &lt;- p(input)))</span>
<span class="co">#         return(list(input=parse$input,</span>
<span class="co">#                     result=structure(list(value=parse$result),class=c(tag,"pAlt"))))</span>
<span class="co">#     }</span>
<span class="co">#     ## All parses failed</span>
<span class="co">#     NULL</span>
<span class="co">#   }</span>
<span class="co"># }</span>
formatAST.pAlt &lt;-<span class="st"> </span>function(x,<span class="dt">indent=</span><span class="dv">0</span>) {
  pad &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="kw">rep</span>(<span class="st">" "</span>,indent),<span class="dt">collapse=</span><span class="st">""</span>)
  <span class="kw">paste</span>(pad,<span class="st">"||"</span>,<span class="kw">class</span>(x)[<span class="dv">1</span>],<span class="st">"; "</span>,<span class="kw">formatAST</span>(x$value),<span class="dt">sep=</span><span class="st">""</span>)
}</code></pre></div>
<p>The sequence combinator creates a parser that succeeds on input accepted by a sequence of simpler parsers applied in succession</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Combin8R:::pSeq
<span class="co"># parserSeq &lt;- function(tag,...) {</span>
<span class="co">#   ps &lt;- list(...)</span>
<span class="co">#   function(input) {</span>
<span class="co">#     ## Try each parser in sequence, accumulating parse results</span>
<span class="co">#     values &lt;- vector(mode="list",length(ps))</span>
<span class="co">#     for(k in seq_along(ps)) {</span>
<span class="co">#       parse &lt;- ps[[k]](input)</span>
<span class="co">#       ## If any match fails, the sequence fails</span>
<span class="co">#       if(is.null(parse)) return(NULL)</span>
<span class="co">#       values[[k]] &lt;- parse$result</span>
<span class="co">#       input &lt;- parse$input</span>
<span class="co">#     }</span>
<span class="co">#     list(input=input,</span>
<span class="co">#          result=structure(list(value=values),class=c(tag,"pSeq")))</span>
<span class="co">#   }</span>
<span class="co"># }</span>
formatAST.pSeq &lt;-<span class="st"> </span>function(x,<span class="dt">indent=</span><span class="dv">0</span>) {
  pad &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="kw">rep</span>(<span class="st">" "</span>,indent),<span class="dt">collapse=</span><span class="st">""</span>)
  <span class="kw">paste</span>(pad,<span class="st">"("</span>,<span class="kw">class</span>(x)[<span class="dv">1</span>],<span class="st">";</span><span class="ch">\n</span><span class="st">"</span>,
        <span class="kw">paste</span>(<span class="kw">sapply</span>(x$value,formatAST,<span class="dt">indent=</span>indent<span class="dv">+2</span>),<span class="dt">collapse=</span><span class="st">""</span>),
        pad,<span class="st">")"</span>,<span class="dt">sep=</span><span class="st">""</span>,<span class="dt">collapse=</span><span class="st">""</span>)
}</code></pre></div>
<p>The many combinator creates a parser that succeeds on input for which a simpler parser succeeds zero or more times when applied in succession. It cannot fail, and it always accepts the longest match.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Combin8R:::pMany
<span class="co"># parserMany &lt;- function(tag,p) {</span>
<span class="co">#   function(input) {</span>
<span class="co">#     k &lt;- 0</span>
<span class="co">#     values &lt;- list()</span>
<span class="co">#     ## Repeatedly try parser, accumulating parse results</span>
<span class="co">#     repeat {</span>
<span class="co">#       parse &lt;- p(input)</span>
<span class="co">#       ## Finish when a parse fails</span>
<span class="co">#       if(is.null(parse)) break</span>
<span class="co">#       values[[k &lt;- k+1]] &lt;- parse$result</span>
<span class="co">#       input &lt;- parse$input</span>
<span class="co">#     }</span>
<span class="co">#     list(input=input,</span>
<span class="co">#          result=structure(list(value=values),class=c(tag,"pMany")))</span>
<span class="co">#   }</span>
<span class="co"># }</span>
formatAST.pMany &lt;-<span class="st"> </span>function(x,<span class="dt">indent=</span><span class="dv">0</span>) {
  pad &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="kw">rep</span>(<span class="st">" "</span>,indent),<span class="dt">collapse=</span><span class="st">""</span>)
  <span class="kw">paste</span>(pad,<span class="st">"*{"</span>,<span class="kw">class</span>(x)[<span class="dv">1</span>],<span class="st">";</span><span class="ch">\n</span><span class="st">"</span>,
        <span class="kw">paste</span>(<span class="kw">sapply</span>(x$value,formatAST,<span class="dt">indent=</span>indent<span class="dv">+2</span>),<span class="dt">collapse=</span><span class="st">""</span>),
        pad,<span class="st">"}"</span>,<span class="dt">sep=</span><span class="st">""</span>)
}</code></pre></div>
<p>A minor variant is the some parser that succeeds on input for which a simpler parser succeeds zero or more times when applied in succession. It can be constructed from <code>parserSeq</code> and <code>parserMany</code> but is used often enough to get its own (more efficient implementation).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">##Combin8R:::pSome
<span class="co"># parserSome &lt;- function(tag,p) {</span>
<span class="co">#   function(input) {</span>
<span class="co">#     parse &lt;- p(input)</span>
<span class="co">#     if(is.null(parse)) return(NULL)</span>
<span class="co">#     k &lt;- 1</span>
<span class="co">#     values &lt;- list(parse$result)</span>
<span class="co">#     ## Continue trying parser, accumulating parse results</span>
<span class="co">#     repeat {</span>
<span class="co">#       parse &lt;- p(input)</span>
<span class="co">#       ## Finish when a parse fails</span>
<span class="co">#       if(is.null(parse)) break</span>
<span class="co">#       values[[k &lt;- k+1]] &lt;- parse$result</span>
<span class="co">#       input &lt;- parse$input</span>
<span class="co">#     }</span>
<span class="co">#     list(input=input,</span>
<span class="co">#          result=structure(list(value=values),class=c(tag,"pSome")))</span>
<span class="co">#   }</span>
<span class="co"># }</span>
formatAST.pSome &lt;-<span class="st"> </span>function(x,<span class="dt">indent=</span><span class="dv">0</span>) {
  pad &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="kw">rep</span>(<span class="st">" "</span>,indent),<span class="dt">collapse=</span><span class="st">""</span>)
  <span class="kw">paste</span>(pad,<span class="st">"+{"</span>,<span class="kw">class</span>(x)[<span class="dv">1</span>],<span class="st">";</span><span class="ch">\n</span><span class="st">"</span>,
      <span class="kw">paste</span>(<span class="kw">sapply</span>(x$value,formatAST,<span class="dt">indent=</span>indent<span class="dv">+2</span>),<span class="dt">collapse=</span><span class="st">""</span>),
      pad,<span class="st">"}"</span>,<span class="dt">sep=</span><span class="st">""</span>)
}</code></pre></div>
<p>So with this framework we can write</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">parserStartPath0 &lt;-
<span class="st">  </span>Combin8R::<span class="kw">pSeq</span>(<span class="st">"StartPath"</span>,
           Combin8R:::<span class="kw">pRegex</span>(<span class="st">"StartText"</span>,<span class="st">"^The waters bounded by a line starting at"</span>),
           parserDMS1,
           parserDMS1,
           Combin8R:::<span class="kw">pRegex</span>(<span class="st">"Semi"</span>,<span class="st">"^;</span><span class="ch">\\</span><span class="st">s*"</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">txt &lt;-<span class="st"> "The waters bounded by a line starting at 57&Atilde;&sbquo;&Acirc;&deg;S 50&Atilde;&sbquo;&Acirc;&deg;W; thence due east to 30&Atilde;&sbquo;&Acirc;&deg;W longitude; thence due south to 64&Atilde;&sbquo;&Acirc;&deg;S latitude; thence due west to 50&Atilde;&sbquo;&Acirc;&deg;W longitude; thence due north to the starting point."</span>
r &lt;-<span class="st"> </span><span class="kw">parserStartPath0</span>(txt)
r$input</code></pre></div>
<pre><code>## [1] "thence due east to 30&Atilde;&lt;U+0082&gt;&Acirc;&deg;W longitude; thence due south to 64&Atilde;&lt;U+0082&gt;&Acirc;&deg;S latitude; thence due west to 50&Atilde;&lt;U+0082&gt;&Acirc;&deg;W longitude; thence due north to the starting point."</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="kw">formatAST</span>(r$result))</code></pre></div>
<pre><code>## (StartPath;
##   [StartText; The waters bounded by a line starting at]
##   [DMS1;  57&Atilde;&lt;U+0082&gt;&Acirc;&deg;S,57,NA,NA,S]
##   [DMS1;  50&Atilde;&lt;U+0082&gt;&Acirc;&deg;W,50,NA,NA,W]
##   [Semi; ; ]
## )</code></pre>
<p>This would be fine for a very general parser where there is some expectation that the input text will contain errors, and we have some interest is locating the point at which the parse fails.</p>
<p>But for your case it is probably simpler to treat whole clauses as single tokens. If we create simple parsers for some common clauses</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## The waters bounded by a line starting at POINT
parserPathStart &lt;-
<span class="st">  </span>Combin8R:::<span class="kw">pRegex</span>(<span class="st">"PathStart"</span>,
               <span class="st">"^</span><span class="ch">\\</span><span class="st">s*The waters bounded by a line starting at (</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)&Atilde;&sbquo;&Acirc;&deg;(?:(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)'(?:(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)</span><span class="ch">\"</span><span class="st">)?)?(N|S) (</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?</span><span class="ch">\\</span><span class="st">d?)&Atilde;&sbquo;&Acirc;&deg;(?:(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)'(?:(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)</span><span class="ch">\"</span><span class="st">)?)?(E|W);</span><span class="ch">\\</span><span class="st">s*"</span>)
## thence due DIRECTION to (PARALLEL|MERIDIAN)
parserPathLineLL &lt;-
<span class="st">  </span>Combin8R:::<span class="kw">pRegex</span>(<span class="st">"PathLineLL"</span>,
              <span class="st">"^</span><span class="ch">\\</span><span class="st">s*thence due (</span><span class="ch">\\</span><span class="st">w+) to (</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?</span><span class="ch">\\</span><span class="st">d?)&Atilde;&sbquo;&Acirc;&deg;(?:(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)'(?:(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)</span><span class="ch">\"</span><span class="st">)?)?(N|S|E|W) (latitude|longitude);</span><span class="ch">\\</span><span class="st">s*"</span>)
<span class="co"># thence DIRECTION to the point POINT</span>
<span class="co"># thence to POINT </span>
parserPathLinePt &lt;-
<span class="st">  </span>Combin8R:::<span class="kw">pRegex</span>(<span class="st">"PathLinePt"</span>,
              <span class="st">"^</span><span class="ch">\\</span><span class="st">s*thence (?:(</span><span class="ch">\\</span><span class="st">w+) )?to (?:the point )?(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)&Atilde;&sbquo;&Acirc;&deg;(?:(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)'(?:(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)</span><span class="ch">\"</span><span class="st">)?)?(N|S), (</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?</span><span class="ch">\\</span><span class="st">d?)&Atilde;&sbquo;&Acirc;&deg;(?:(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)'(?:(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)</span><span class="ch">\"</span><span class="st">)?)?(E|W);</span><span class="ch">\\</span><span class="st">s*"</span>)
## thence due DIRECTION to the starting point.
parserPathEnd &lt;-
<span class="st">  </span>Combin8R:::<span class="kw">pRegex</span>(<span class="st">"PathEnd"</span>,
              <span class="st">"^</span><span class="ch">\\</span><span class="st">s*thence due (</span><span class="ch">\\</span><span class="st">w+) to the starting point.</span><span class="ch">\\</span><span class="st">s*"</span>)</code></pre></div>
<p>These can be combined to form a parser for the simpler description</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">parserPath &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">pSeq</span>(<span class="st">"Path"</span>,
            parserPathStart,
            <span class="kw">pSome</span>(<span class="st">"PathLineList"</span>,
                       <span class="kw">pAlt</span>(<span class="st">"parserPathLine"</span>,
                                 parserPathLineLL,
                                 parserPathLinePt)),
            parserPathEnd)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">r &lt;-<span class="st"> </span><span class="kw">parserPath</span>(txt)
<span class="kw">cat</span>(<span class="kw">formatAST</span>(r$result))</code></pre></div>
<pre><code>## (Path;
##   [PathStart; The waters bounded by a line starting at 57&Atilde;&lt;U+0082&gt;&Acirc;&deg;S 50&Atilde;&lt;U+0082&gt;&Acirc;&deg;W; ,57,NA,NA,S,50,NA,NA,W]
##   +{PathLineList;
##     ||parserPathLine; [PathLineLL; thence due east to 30&Atilde;&lt;U+0082&gt;&Acirc;&deg;W longitude; ,east,30,NA,NA,W,longitude]
##     ||parserPathLine; [PathLineLL; thence due south to 64&Atilde;&lt;U+0082&gt;&Acirc;&deg;S latitude; ,south,64,NA,NA,S,latitude]
##     ||parserPathLine; [PathLineLL; thence due west to 50&Atilde;&lt;U+0082&gt;&Acirc;&deg;W longitude; ,west,50,NA,NA,W,longitude]
##   }  [PathEnd; thence due north to the starting point.,north]
## )</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">txt &lt;-<span class="st"> "The waters bounded by a line starting at 45&Atilde;&sbquo;&Acirc;&deg;S 60&Atilde;&sbquo;&Acirc;&deg;E; thence due south to 53&Atilde;&sbquo;&Acirc;&deg;14'S latitude; thence east to the point 53&Atilde;&sbquo;&Acirc;&deg;14'07</span><span class="ch">\"</span><span class="st">S, 67&Atilde;&sbquo;&Acirc;&deg;03'20</span><span class="ch">\"</span><span class="st">E; thence to 52&Atilde;&sbquo;&Acirc;&deg;42'28</span><span class="ch">\"</span><span class="st">S, 68&Atilde;&sbquo;&Acirc;&deg;05'31</span><span class="ch">\"</span><span class="st">E; thence to 51&Atilde;&sbquo;&Acirc;&deg;58'18</span><span class="ch">\"</span><span class="st">S, 69&Atilde;&sbquo;&Acirc;&deg;44'02</span><span class="ch">\"</span><span class="st">E; thence to 51&Atilde;&sbquo;&Acirc;&deg;24'32</span><span class="ch">\"</span><span class="st">S, 71&Atilde;&sbquo;&Acirc;&deg;12'29</span><span class="ch">\"</span><span class="st">E; thence to 51&Atilde;&sbquo;&Acirc;&deg;03'09</span><span class="ch">\"</span><span class="st">S, 72&Atilde;&sbquo;&Acirc;&deg;28'28</span><span class="ch">\"</span><span class="st">E; thence to 50&Atilde;&sbquo;&Acirc;&deg;54'23</span><span class="ch">\"</span><span class="st">S, 72&Atilde;&sbquo;&Acirc;&deg;49'21</span><span class="ch">\"</span><span class="st">E; thence to 49&Atilde;&sbquo;&Acirc;&deg;49'34</span><span class="ch">\"</span><span class="st">S, 75&Atilde;&sbquo;&Acirc;&deg;36'08</span><span class="ch">\"</span><span class="st">E; thence to 49&Atilde;&sbquo;&Acirc;&deg;24'07</span><span class="ch">\"</span><span class="st">S, 76&Atilde;&sbquo;&Acirc;&deg;42'17</span><span class="ch">\"</span><span class="st">E; thence due east to 80&Atilde;&sbquo;&Acirc;&deg;E longitude; thence due north to 45&Atilde;&sbquo;&Acirc;&deg;S latitude; thence due west to the starting point."</span>
r1 &lt;-<span class="st"> </span><span class="kw">parserPath</span>(txt)
<span class="kw">cat</span>(<span class="kw">formatAST</span>(r1$result))</code></pre></div>
<pre><code>## (Path;
##   [PathStart; The waters bounded by a line starting at 45&Atilde;&lt;U+0082&gt;&Acirc;&deg;S 60&Atilde;&lt;U+0082&gt;&Acirc;&deg;E; ,45,NA,NA,S,60,NA,NA,E]
##   +{PathLineList;
##     ||parserPathLine; [PathLineLL; thence due south to 53&Atilde;&lt;U+0082&gt;&Acirc;&deg;14'S latitude; ,south,53,14,NA,S,latitude]
##     ||parserPathLine; [PathLinePt; thence east to the point 53&Atilde;&lt;U+0082&gt;&Acirc;&deg;14'07"S, 67&Atilde;&lt;U+0082&gt;&Acirc;&deg;03'20"E; ,east,53,14,07,S,67,03,20,E]
##     ||parserPathLine; [PathLinePt; thence to 52&Atilde;&lt;U+0082&gt;&Acirc;&deg;42'28"S, 68&Atilde;&lt;U+0082&gt;&Acirc;&deg;05'31"E; ,NA,52,42,28,S,68,05,31,E]
##     ||parserPathLine; [PathLinePt; thence to 51&Atilde;&lt;U+0082&gt;&Acirc;&deg;58'18"S, 69&Atilde;&lt;U+0082&gt;&Acirc;&deg;44'02"E; ,NA,51,58,18,S,69,44,02,E]
##     ||parserPathLine; [PathLinePt; thence to 51&Atilde;&lt;U+0082&gt;&Acirc;&deg;24'32"S, 71&Atilde;&lt;U+0082&gt;&Acirc;&deg;12'29"E; ,NA,51,24,32,S,71,12,29,E]
##     ||parserPathLine; [PathLinePt; thence to 51&Atilde;&lt;U+0082&gt;&Acirc;&deg;03'09"S, 72&Atilde;&lt;U+0082&gt;&Acirc;&deg;28'28"E; ,NA,51,03,09,S,72,28,28,E]
##     ||parserPathLine; [PathLinePt; thence to 50&Atilde;&lt;U+0082&gt;&Acirc;&deg;54'23"S, 72&Atilde;&lt;U+0082&gt;&Acirc;&deg;49'21"E; ,NA,50,54,23,S,72,49,21,E]
##     ||parserPathLine; [PathLinePt; thence to 49&Atilde;&lt;U+0082&gt;&Acirc;&deg;49'34"S, 75&Atilde;&lt;U+0082&gt;&Acirc;&deg;36'08"E; ,NA,49,49,34,S,75,36,08,E]
##     ||parserPathLine; [PathLinePt; thence to 49&Atilde;&lt;U+0082&gt;&Acirc;&deg;24'07"S, 76&Atilde;&lt;U+0082&gt;&Acirc;&deg;42'17"E; ,NA,49,24,07,S,76,42,17,E]
##     ||parserPathLine; [PathLineLL; thence due east to 80&Atilde;&lt;U+0082&gt;&Acirc;&deg;E longitude; ,east,80,NA,NA,E,longitude]
##     ||parserPathLine; [PathLineLL; thence due north to 45&Atilde;&lt;U+0082&gt;&Acirc;&deg;S latitude; ,north,45,NA,NA,S,latitude]
##   }  [PathEnd; thence due west to the starting point.,west]
## )</code></pre>
<p>This still needs more work to cater for clauses such as</p>
<ul><li><p>thence westward along the coast of the Antarctic Continent to 20&Atilde;&sbquo;&Acirc;&deg;W longitude</p></li>
<li><p>thence westward along and including the coast of the Antarctic Peninsula to 75&Atilde;&sbquo;&Acirc;&deg;W longitude</p></li>
<li><p>thence westward along the coast of the Antarctic Continent and northwards along the coast of the Antarctic Peninsula to 65&Atilde;&sbquo;&Acirc;&deg;S latitude</p></li>
<li><p>thence westward along the coast of the Antarctic Continent, the Weddell Sea and the Antarctic Peninsula to 70&Atilde;&sbquo;&Acirc;&deg;W longitude, where the meridian meets the coast of Ellsworth Land</p></li>
<li><p>thence north across George VI Sound and due north to 60&Atilde;&sbquo;&Acirc;&deg;S latitude</p></li>
<li><p>thence around the peninsula to 70&Atilde;&sbquo;&Acirc;&deg;W longitude, where the meridian meets the coast of Ellsworth Land</p></li>
<li><p>thence due west to the eastern coast of the Antarctic Peninsula</p></li>
</ul><p>We could either put something together with parserRegex, or we could write a handcrafted parser for these more compex clauses.</p>
<p>This then has to be embedded into a larger parser that identifies</p>
<ul><li>Areas</li>
<li>SubAreas</li>
<li>Divisions</li>
<li>Subdivisions</li>
<li>Integrated Study Regions</li>
</ul></div>
</div>
</div>
<div id="explicit-lexer" class="section level2">
<h2 class="hasAnchor"><html><body><a href="#explicit-lexer" class="anchor"> </a></body></html>Explicit Lexer</h2>
<p>If we were to make the lexing phase explicit, we would write a lexer that converts the input into a stream of tokens (or lexemes). Part of the trick is that the tokens must be recognisable independent of context in which they are used.</p>
<p>The individual lexers are defined in terms of regular expression</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(stringi)
lexerRegexp &lt;-<span class="st"> </span>function(tag,regex)
  function(input) {
    match &lt;-<span class="st"> </span><span class="kw">stri_match_first_regex</span>(input,regex)
    ## If the regex matched, consume input and return any captured
    ## groups as values
    if(!<span class="kw">is.na</span>(match[<span class="dv">1</span>,<span class="dv">1</span>]))
      <span class="kw">list</span>(<span class="dt">input=</span><span class="kw">substr</span>(input,<span class="kw">nchar</span>(match[<span class="dv">1</span>,<span class="dv">1</span>])+<span class="dv">1</span>,<span class="kw">nchar</span>(input)),
           <span class="dt">token=</span><span class="kw">structure</span>(<span class="kw">list</span>(<span class="dt">values=</span>match[<span class="dv">1</span>,-<span class="dv">1</span>]),<span class="dt">class=</span><span class="kw">c</span>(tag,<span class="st">"lRegex"</span>)))
  }
print.lRegex &lt;-<span class="st"> </span>function(x,...) {
  <span class="kw">cat</span>(<span class="kw">class</span>(x)[<span class="dv">1</span>],<span class="st">":"</span>,x$values)
}
formatAST.lRegex &lt;-<span class="st"> </span>function(x,<span class="dt">indent=</span><span class="dv">0</span>) {
  pad &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="kw">rep</span>(<span class="st">" "</span>,indent),<span class="dt">collapse=</span><span class="st">""</span>)
  <span class="kw">paste</span>(pad,<span class="st">"["</span>,<span class="kw">class</span>(x)[<span class="dv">1</span>],<span class="st">"; "</span>,<span class="kw">paste</span>(x$value,<span class="dt">collapse=</span><span class="st">" "</span>),<span class="st">"]</span><span class="ch">\n</span><span class="st">"</span>,<span class="dt">sep=</span><span class="st">""</span>)
}</code></pre></div>
<p>The lexer generator is like a combination of <code>parseMany</code> and <code>parseSeq</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">makeLexer &lt;-<span class="st"> </span>function(...) {
  ls &lt;-<span class="st"> </span><span class="kw">list</span>(...)
  tokens &lt;-<span class="st"> </span><span class="kw">list</span>()
  
  function(input) {
    k &lt;-<span class="st"> </span><span class="dv">0</span>
    repeat {
      ## Return if input consumed
      if(<span class="kw">nchar</span>(input)==<span class="dv">0</span>) <span class="kw">return</span>(<span class="kw">list</span>(<span class="dt">input=</span>input,<span class="dt">tokens=</span>tokens))
      ## Call lexers
      for(l in ls)
        if(!<span class="kw">is.null</span>(lex &lt;-<span class="st"> </span><span class="kw">l</span>(input))) break
      ## If all failed return partial result
      if(<span class="kw">is.null</span>(lex)) <span class="kw">return</span>(<span class="kw">list</span>(<span class="dt">input=</span>input,<span class="dt">tokens=</span>tokens))
      ## Else store token and consume input
      tokens[[k &lt;-<span class="st"> </span>k<span class="dv">+1</span>]] &lt;-<span class="st"> </span>lex$token
      input &lt;-<span class="st"> </span>lex$input
    }
  }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">lexer &lt;-<span class="st"> </span><span class="kw">makeLexer</span>(
  ## The waters bounded by a line starting at POINT
  <span class="kw">lexerRegexp</span>(<span class="st">"PathStart"</span>,
              <span class="st">"^</span><span class="ch">\\</span><span class="st">s*The waters bounded by a line starting at (</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)&Atilde;&sbquo;&Acirc;&deg;(?:(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)'(?:(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)</span><span class="ch">\"</span><span class="st">)?)?(N|S) (</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?</span><span class="ch">\\</span><span class="st">d?)&Atilde;&sbquo;&Acirc;&deg;(?:(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)'(?:(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)</span><span class="ch">\"</span><span class="st">)?)?(E|W);</span><span class="ch">\\</span><span class="st">s*"</span>),
  ## thence due DIRECTION to (PARALLEL|MERIDIAN)
  <span class="kw">lexerRegexp</span>(<span class="st">"PathLineLL"</span>,
              <span class="st">"^</span><span class="ch">\\</span><span class="st">s*thence due (</span><span class="ch">\\</span><span class="st">w+) to (</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?</span><span class="ch">\\</span><span class="st">d?)&Atilde;&sbquo;&Acirc;&deg;(?:(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)'(?:(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)</span><span class="ch">\"</span><span class="st">)?)?(N|S|E|W) (latitude|longitude);</span><span class="ch">\\</span><span class="st">s*"</span>),
  <span class="co"># thence DIRECTION to the point POINT</span>
  <span class="co"># thence to POINT </span>
  <span class="kw">lexerRegexp</span>(<span class="st">"PathLinePt"</span>,
              <span class="st">"^</span><span class="ch">\\</span><span class="st">s*thence (?:(</span><span class="ch">\\</span><span class="st">w+) )?to (?:the point )?(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)&Atilde;&sbquo;&Acirc;&deg;(?:(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)'(?:(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)</span><span class="ch">\"</span><span class="st">)?)?(N|S), (</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?</span><span class="ch">\\</span><span class="st">d?)&Atilde;&sbquo;&Acirc;&deg;(?:(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)'(?:(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d?)</span><span class="ch">\"</span><span class="st">)?)?(E|W);</span><span class="ch">\\</span><span class="st">s*"</span>),
  ## thence due DIRECTION to the starting point.
  <span class="kw">lexerRegexp</span>(<span class="st">"PathEnd"</span>,
              <span class="st">"^</span><span class="ch">\\</span><span class="st">s*thence due (</span><span class="ch">\\</span><span class="st">w+) to the starting point.</span><span class="ch">\\</span><span class="st">s*"</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">txt &lt;-<span class="st"> "The waters bounded by a line starting at 45&Atilde;&sbquo;&Acirc;&deg;S 60&Atilde;&sbquo;&Acirc;&deg;E; thence due south to 53&Atilde;&sbquo;&Acirc;&deg;14'S latitude; thence east to the point 53&Atilde;&sbquo;&Acirc;&deg;14'07</span><span class="ch">\"</span><span class="st">S, 67&Atilde;&sbquo;&Acirc;&deg;03'20</span><span class="ch">\"</span><span class="st">E; thence to 52&Atilde;&sbquo;&Acirc;&deg;42'28</span><span class="ch">\"</span><span class="st">S, 68&Atilde;&sbquo;&Acirc;&deg;05'31</span><span class="ch">\"</span><span class="st">E; thence to 51&Atilde;&sbquo;&Acirc;&deg;58'18</span><span class="ch">\"</span><span class="st">S, 69&Atilde;&sbquo;&Acirc;&deg;44'02</span><span class="ch">\"</span><span class="st">E; thence to 51&Atilde;&sbquo;&Acirc;&deg;24'32</span><span class="ch">\"</span><span class="st">S, 71&Atilde;&sbquo;&Acirc;&deg;12'29</span><span class="ch">\"</span><span class="st">E; thence to 51&Atilde;&sbquo;&Acirc;&deg;03'09</span><span class="ch">\"</span><span class="st">S, 72&Atilde;&sbquo;&Acirc;&deg;28'28</span><span class="ch">\"</span><span class="st">E; thence to 50&Atilde;&sbquo;&Acirc;&deg;54'23</span><span class="ch">\"</span><span class="st">S, 72&Atilde;&sbquo;&Acirc;&deg;49'21</span><span class="ch">\"</span><span class="st">E; thence to 49&Atilde;&sbquo;&Acirc;&deg;49'34</span><span class="ch">\"</span><span class="st">S, 75&Atilde;&sbquo;&Acirc;&deg;36'08</span><span class="ch">\"</span><span class="st">E; thence to 49&Atilde;&sbquo;&Acirc;&deg;24'07</span><span class="ch">\"</span><span class="st">S, 76&Atilde;&sbquo;&Acirc;&deg;42'17</span><span class="ch">\"</span><span class="st">E; thence due east to 80&Atilde;&sbquo;&Acirc;&deg;E longitude; thence due north to 45&Atilde;&sbquo;&Acirc;&deg;S latitude; thence due west to the starting point."</span>
lex &lt;-<span class="st"> </span><span class="kw">lexer</span>(txt)
lex$tokens</code></pre></div>
<pre><code>## [[1]]
## $values
## [1] "45" NA   NA   "S"  "60" NA   NA   "E" 
## 
## attr(,"class")
## [1] "PathStart" "lRegex"   
## 
## [[2]]
## $values
## [1] "south"    "53"       "14"       NA         "S"        "latitude"
## 
## attr(,"class")
## [1] "PathLineLL" "lRegex"    
## 
## [[3]]
## $values
## [1] "east" "53"   "14"   "07"   "S"    "67"   "03"   "20"   "E"   
## 
## attr(,"class")
## [1] "PathLinePt" "lRegex"    
## 
## [[4]]
## $values
## [1] NA   "52" "42" "28" "S"  "68" "05" "31" "E" 
## 
## attr(,"class")
## [1] "PathLinePt" "lRegex"    
## 
## [[5]]
## $values
## [1] NA   "51" "58" "18" "S"  "69" "44" "02" "E" 
## 
## attr(,"class")
## [1] "PathLinePt" "lRegex"    
## 
## [[6]]
## $values
## [1] NA   "51" "24" "32" "S"  "71" "12" "29" "E" 
## 
## attr(,"class")
## [1] "PathLinePt" "lRegex"    
## 
## [[7]]
## $values
## [1] NA   "51" "03" "09" "S"  "72" "28" "28" "E" 
## 
## attr(,"class")
## [1] "PathLinePt" "lRegex"    
## 
## [[8]]
## $values
## [1] NA   "50" "54" "23" "S"  "72" "49" "21" "E" 
## 
## attr(,"class")
## [1] "PathLinePt" "lRegex"    
## 
## [[9]]
## $values
## [1] NA   "49" "49" "34" "S"  "75" "36" "08" "E" 
## 
## attr(,"class")
## [1] "PathLinePt" "lRegex"    
## 
## [[10]]
## $values
## [1] NA   "49" "24" "07" "S"  "76" "42" "17" "E" 
## 
## attr(,"class")
## [1] "PathLinePt" "lRegex"    
## 
## [[11]]
## $values
## [1] "east"      "80"        NA          NA          "E"         "longitude"
## 
## attr(,"class")
## [1] "PathLineLL" "lRegex"    
## 
## [[12]]
## $values
## [1] "north"    "45"       NA         NA         "S"        "latitude"
## 
## attr(,"class")
## [1] "PathLineLL" "lRegex"    
## 
## [[13]]
## $values
## [1] "west"
## 
## attr(,"class")
## [1] "PathEnd" "lRegex"</code></pre>
<p>So the input text is converted to a list of tokens. The <code>parserRegex</code> function becomes replaced with a function <code>parserToken</code> that checks the class of the token and consumes the matching token off the input stream</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">parserToken &lt;-<span class="st"> </span>function(token)
  function(input) {
    if(<span class="kw">length</span>(input) &gt;<span class="st"> </span><span class="dv">0</span> &amp;&amp;<span class="st"> </span><span class="kw">class</span>(input[[<span class="dv">1</span>]])[<span class="dv">1</span>] ==<span class="st"> </span>token)
      <span class="kw">list</span>(<span class="dt">input=</span>input[-<span class="dv">1</span>],<span class="dt">result=</span>input[[<span class="dv">1</span>]])
  }</code></pre></div>
<p>and the combinators stay more or less the same. These can be combined to form a parser for the simpler description</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">parserPath &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">pSeq</span>(<span class="st">"Path"</span>,
            <span class="kw">parserToken</span>(<span class="st">"PathStart"</span>),
            <span class="kw">pSome</span>(<span class="st">"PathLineList"</span>,
                       <span class="kw">pAlt</span>(<span class="st">"parserPathLine"</span>,
                                 <span class="kw">parserToken</span>(<span class="st">"PathLineLL"</span>),
                                 <span class="kw">parserToken</span>(<span class="st">"PathLinePt"</span>))),
            <span class="kw">parserToken</span>(<span class="st">"PathEnd"</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">r2 &lt;-<span class="st"> </span><span class="kw">parserPath</span>(lex$tokens)
 <span class="kw">cat</span>(<span class="kw">formatAST</span>(r2$result))</code></pre></div>
<pre><code>## (Path;
## c("  structure(list(values = c(\"45\", NA, NA, \"S\", \"60\", NA, NA, \"E\"", "  )), .Names = \"values\", class = c(\"PathStart\", \"lRegex\"))")  +{PathLineList;
## c("    ||parserPathLine; structure(list(values = c(\"south\", \"53\", \"14\", NA, \"S\", \"latitude\"", "    ||parserPathLine; )), .Names = \"values\", class = c(\"PathLineLL\", \"lRegex\"))")c("    ||parserPathLine; structure(list(values = c(\"east\", \"53\", \"14\", \"07\", \"S\", \"67\", ", "    ||parserPathLine; \"03\", \"20\", \"E\")), .Names = \"values\", class = c(\"PathLinePt\", ", "    ||parserPathLine; \"lRegex\"))")c("    ||parserPathLine; structure(list(values = c(NA, \"52\", \"42\", \"28\", \"S\", \"68\", \"05\", ", "    ||parserPathLine; \"31\", \"E\")), .Names = \"values\", class = c(\"PathLinePt\", \"lRegex\"", "    ||parserPathLine; ))")c("    ||parserPathLine; structure(list(values = c(NA, \"51\", \"58\", \"18\", \"S\", \"69\", \"44\", ", "    ||parserPathLine; \"02\", \"E\")), .Names = \"values\", class = c(\"PathLinePt\", \"lRegex\"", "    ||parserPathLine; ))")c("    ||parserPathLine; structure(list(values = c(NA, \"51\", \"24\", \"32\", \"S\", \"71\", \"12\", ", "    ||parserPathLine; \"29\", \"E\")), .Names = \"values\", class = c(\"PathLinePt\", \"lRegex\"", "    ||parserPathLine; ))")c("    ||parserPathLine; structure(list(values = c(NA, \"51\", \"03\", \"09\", \"S\", \"72\", \"28\", ", "    ||parserPathLine; \"28\", \"E\")), .Names = \"values\", class = c(\"PathLinePt\", \"lRegex\"", "    ||parserPathLine; ))")c("    ||parserPathLine; structure(list(values = c(NA, \"50\", \"54\", \"23\", \"S\", \"72\", \"49\", ", "    ||parserPathLine; \"21\", \"E\")), .Names = \"values\", class = c(\"PathLinePt\", \"lRegex\"", "    ||parserPathLine; ))")c("    ||parserPathLine; structure(list(values = c(NA, \"49\", \"49\", \"34\", \"S\", \"75\", \"36\", ", "    ||parserPathLine; \"08\", \"E\")), .Names = \"values\", class = c(\"PathLinePt\", \"lRegex\"", "    ||parserPathLine; ))")c("    ||parserPathLine; structure(list(values = c(NA, \"49\", \"24\", \"07\", \"S\", \"76\", \"42\", ", "    ||parserPathLine; \"17\", \"E\")), .Names = \"values\", class = c(\"PathLinePt\", \"lRegex\"", "    ||parserPathLine; ))")c("    ||parserPathLine; structure(list(values = c(\"east\", \"80\", NA, NA, \"E\", \"longitude\"", "    ||parserPathLine; )), .Names = \"values\", class = c(\"PathLineLL\", \"lRegex\"))")c("    ||parserPathLine; structure(list(values = c(\"north\", \"45\", NA, NA, \"S\", \"latitude\"", "    ||parserPathLine; )), .Names = \"values\", class = c(\"PathLineLL\", \"lRegex\"))")  }c("  structure(list(values = \"west\"), .Names = \"values\", class = c(\"PathEnd\", ", "  \"lRegex\"))"))</code></pre>
<p>Oddly, efficiency here comes down to the efficiency with which we can subset R&rsquo;s lists versus R&rsquo;s strings. It is not clear that an explicit lexer will make things faster in R.</p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2>Contents</h2>
      <ul class="nav nav-pills nav-stacked"><li><a href="#ccamlr-convention-areas">CCAMLR Convention Areas</a></li>
      <li><a href="#parsing">Parsing</a></li>
      <li><a href="#parser-combinators">Parser Combinators</a></li>
      <li><a href="#explicit-lexer">Explicit Lexer</a></li>
      </ul></div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Michael D. Sumner, Simon Wotherspoon.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer></div>

  </body></html>
